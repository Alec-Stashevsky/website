---
title: "Topology and Geometry Through GraphML"
author: "Alec Stashevsky"
date: 2022-11-26
categories: ["Mathematics", "GraphML", "Deep Learning"]
tags: ["Mathematics", "GraphML", "Deep Learning"]
bibliography: [topology-vs-geometry.bib]
link-citations: true
links:
image:
  preview_only: false
  focal_point: "Smart"
summary: Diving deeper into mathematics through my journey with industrial GraphML application.
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, dev = "svg")
library(ggplot2)
library(network)
library(sna)
library(kableExtra)
library(AlecWebsiteThmr)
library(GGally)
set.seed(32)
```

```{css Table CSS, echo=FALSE}
table {
   overflow-x: hidden;
}

table > thead > tr > th {
    vertical-align: bottom;
    border-bottom: 2px solid rgb(232, 215, 195);
}

table > thead > tr > th, table > tbody > tr > th, table > tfoot > tr > th, table > thead > tr > td, table > tbody > tr > td, table > tfoot > tr > td {
    padding: 8px;
    line-height: 1.43;
    vertical-align: top;
    border-top: 1px solid rgb(232, 215, 195);
}

tbody > tr > td, table > tbody > tr > th {
    padding: 8px;
    line-height: 1.43;
    vertical-align: top;
    border-bottom: 1px solid rgb(232, 215, 195);
}


table > tfoot > tr > td {
    padding: 8px;
    line-height: 1.43;
    vertical-align: top;
    border-top: none;
}



table > tbody > tr:nth-child(2n+1) > td, table > tbody > tr:nth-child(2n+1) > th {
    background-color: rgb(255, 248, 227);
}

# Hover
table > tbody > tr:nth-child(2n+1):hover > td, table > tbody > tr:nth-child(2n+1):hover > th {
    background-color: rgb(232, 215, 195);
}

table > tbody > tr:hover > td, table > tbody > tr:hover > th {
    background-color: rgb(232, 215, 195);
}
```

```{css References CSS, echo=FALSE}
#references {
    text-indent: -2em;
    margin-left: 2em;
}
```

> There is no royal road to geometry.
>
> [--- Euclid, *on account of Proclus of Athens*]{style="float:right"}
>

<br>

This was Euclid's response when asked by Ptolemy if no shorter road to geometry existed than through his *Elements. <link>*^[*See* @Morrow1992-MORPAC-8.]

<br>

For the past year I've been working with a team of folks at [Fetch](https://fetch.com/) to develop and productionalize a machine learning based document understanding pipeline powering the core of the Fetch Rewards app. At Fetch, we reward our users for snapping pictures of their receipts in real-time, and we do it using this pipeline.

During this process, one of the things I've spent more time trying to do is understand unstructured data (such as images of receipts and the text which appears on them) in more elegant ways. This led me to a new and exciting place flourishing within the ML community: Graph Machine Learning (GraphML). 

This post is about some of the things I've learned participating in the GraphML and Geometric Deep Learning communities. This post is also about some of the things I've had to forget in applying GraphML in large-scale industrial settings. 

<br>

## Graphs Are All Around Us 

When first learning about graphs, one usually encounters something like the following: 

```{r basic graph, echo=FALSE, message=FALSE, warning=FALSE}
# Create static graph
net <- structure(
  list(
    mel = list(
      list(inl = 1L, outl = 2L, atl = list(na = FALSE)),
      list(inl = 1L, outl = 3L, atl = list(na = FALSE)), 
      list(inl = 2L, outl = 3L, atl = list(na = FALSE)),
      list(inl = 3L, outl = 5L, atl = list(na = FALSE)),
      list(inl = 4L, outl = 5L, atl = list(na = FALSE))
      ),
    gal = list(n = 5, mnext = 6L, directed = FALSE,
               hyper = FALSE, loops = FALSE,
               multiple = FALSE, bipartite = FALSE
               ),
    val = list(list(na = FALSE, vertex.names = 1L, color = "type1"),
               list(na = FALSE, vertex.names = 2L, color = "type2"), 
               list(na = FALSE, vertex.names = 3L, color = "type1"),
               list(na = FALSE, vertex.names = 4L, color = "type2"),
               list(na = FALSE, vertex.names = 5L, color = "type1")
               ),
    iel = list(2:1, 3L, 4L, 5L, integer(0)),
    oel = list(integer(0), 1L, 2:3, integer(0), 4:5)
    ),
  class = "network")

# Plot the graph
ggnet2(
  net,
  color = rep(c(get_primary_color()), 5),
  edge.size = 1,
  edge.color = "#8f7346",
  label = TRUE,
  label.color = "white",
  label.alpha = 0.7
  ) + 
  theme_AlecWebsite() +
  labs(x = "", y = "")
```

A collection of *nodes* or *vertices* represented as dark green circles connected by a series of *edges* or *links* which indicate some pairwise relationship between two nodes.

Graphs are incredibly simple yet flexible data structures. Nodes and edges and can be added or removed as we please. We can also move, bend, and reorder the nodes without changing the underlying relational structure of the graph. That is, without changing the fundamental nature of the graph itself. For example, below I've moved some of the nodes of the graph around and switched node 3 and node 5.

```{r basic graph2, echo=FALSE, message=FALSE, warning=FALSE}
# Create static graph
net2 <- structure(
  list(
    mel = list(
      list(inl = 1L, outl = 2L, atl = list(na = FALSE)),
      list(inl = 1L, outl = 3L, atl = list(na = FALSE)), 
      list(inl = 2L, outl = 3L, atl = list(na = FALSE)),
      list(inl = 3L, outl = 5L, atl = list(na = FALSE)),
      list(inl = 4L, outl = 5L, atl = list(na = FALSE))
      ),
    gal = list(n = 5, mnext = 6L, directed = FALSE,
               hyper = FALSE, loops = FALSE,
               multiple = FALSE, bipartite = FALSE
               ),
    val = list(list(na = FALSE, vertex.names = 1L, color = "type1"),
               list(na = FALSE, vertex.names = 2L, color = "type2"), 
               list(na = FALSE, vertex.names = 5L, color = "type1"),
               list(na = FALSE, vertex.names = 4L, color = "type2"),
               list(na = FALSE, vertex.names = 3L, color = "type1")
               ),
    iel = list(2:1, 3L, 4L, 5L, integer(0)),
    oel = list(integer(0), 1L, 2:3, integer(0), 4:5)
    ),
  class = "network")

# Plot the graph
ggnet2(
  net2,
  mode = "circle",
  color = rep(c(get_primary_color()), 5),
  edge.size = 1,
  edge.color = "#8f7346",
  label = TRUE,
  label.color = "white",
  label.alpha = 0.7
  ) + 
  theme_AlecWebsite() +
  labs(x = "", y = "")
```

Despite these modifications, the graph describes the same type of basic relational structure. We refer to this underlying structure as the graph's *connectivity* or the *topology* of the graph. The graph's topology is agnostic of where we position these nodes in space, or what we name individual nodes. 

This also means graphs exist outside of Euclidean space where we have explicit notions of distance. I have no way of telling if node 3 is closer to node 4 or node 5 even though they appear father apart in the two examples above. Graphs like these, in their most basic form, do not model Euclid's geometry. Perhaps there is a shorter road after all?


### What Happens When We See Them?

One of the reasons GraphML is such an exciting space is just how abundant graphs are. A salient place to apply GraphML is in the modelling of molecules (link), where atoms are represented as nodes and their chemical bonds represented as edges. We also see social networks where user-profiles are nodes and their friendships, followers, or interactions form edges; financial networks with bank accounts as nodes and their transactions as edges of varying amounts; and even more recently, documents. 

Where graphs can be seen, GraphML is there to teach machines how to make conclusions about them, and new unseen things we might later encounter. GraphML is being used to discover new therapeutic drugs (link), prevent the spread of misinformation in social networks (link to siraj) (and probably also help it too), identify bank fraud (capitalOne), and understand documents (link to graph paper).

As data scientists and machine learning researchers, our main goal is to make sense of the world around us. We do some of that by building models in and through which our understanding may grow. When we begin to see graph structure and its natural projections onto the world, we unlock a deeper and more organic connection by which to explain and infer phenomena. One of the ways graphs unlock this connection is through a blending of topological and geometric perspective.


## Adding Geometry to Graphs

For machines to learn on data, be it graph-structured or not, we must represent the data in a way computers can digest. That is to say, we must encode the data into some *n*-dimensional (generally Euclidean) vector space, where individual data points can be represented as vectors within that space.

For example, consider GPS telemetry data used to monitor the movement of a newly released California Condor.^[Picture provided by James Sheppard. *See* https://blogs.biomedcentral.com/bmcseriesblog/2015/09/02/behind-image-3d-home-range-california-condor/.] 

![](condor_3d_map.jpeg)

The data used to make that visualization might look something like this:

```{r encoded condor data, echo=FALSE, message=FALSE, warning=FALSE}
# Load data
encoded_condor_data <- readRDS("~/Git/website/content/post/topology-vs-geometry/encoded_condor_telemetry.RDs")

# Plot table
knitr::kable(
   encoded_condor_data,
   format = "html",
   row.names = FALSE,
   align = c("l", "c", "c", "c", "c"),
   escape = FALSE
   ) %>% 
   add_header_above(
      c("Condor GPS Telemetry Data" = 5),
      align = "c",
      escape = TRUE,
      line = FALSE,
      extra_css = "background-color: rgb(232, 215, 195); font-size: 1rem; padding: 0.15rem 0;"
      ) %>%
  footnote(
      general_title = "Notes:",
      title_format = "bold",
      general =
        "--- The Time column is normalized from 0 to 1 which represent the start and end of the tracking period, respectively. <br>
         --- Each condor has an identification number. Condor 190 is  <a href='https://www.ventanaws.org/condor190.html'>Redwood Queen</a> and Condor 1031 is one of her offspring,  <a href='https://www.ventanaws.org/condor1031.html'>Iniko</a>. Redwood Queen and Iniko are real California Condors which are part of the free-ranging Central California flock! They have an amazing <a href='https://www.wildtones.com/birding-info/the-story-of-condor-chick-iniko'>story</a>.",
      escape = FALSE
  )
```


To represent this data in some vector space, we need to encode it as numerical vectors. There are may different ways to do this. What is described below is certainly not the best way, but it keeps things simple. We perform the following transformations:

1. Represent the *Time* column as a scale from *0* to *1* where *0* is the first point in time we start tracking and 1 is the last
2. Number the *Condors* column from *1* to *n* where *n* is the number of condors we track in the data
3. Keep all other columns as is

Now, our data looks something like this:

Each observation in the table can be represented as a column vector, like the one below. The elements of the vector now describe a part of a data point as a real number.

$$ \begin{bmatrix} Time \\ Condor \\ Latitude \\ Longitude \\ Altitude \end{bmatrix} \in \mathbb{R}^5  $$

This process introduces a *geometry* to our dataset 

- embedding space. Now we can see how "far apart" nodes are by looking at their feature vectors.
- talk about thinking about conventional relational data as graphs, how that induces a geometry in the graph.
- images as graphs, molecules as graphs. 



<!-- Bring this back at the end of post -->
## Teaching Machines to Comprehend Documents
*Document Understanding* and *Document AI* are fields which use automated methods (specifically artificial intelligence in the case of the latter) to comprehend documents, such as scanned invoices, emails, legal filings(link?), and in our case: receipts. Document Understanding is a broad field which touches a wide range of sub fields within AI: Computer Vision (CV), Natural Language Processing (NLP), and even Graph Machine Learning (GraphML) (links?).           


Industrial application of document AI is equally broad and includes:^[*See* https://huggingface.co/blog/document-ai.]

* Identifying types of document (image classification)
* Make document text searchable (optical character recognition)
* Extracting and identifying important peices of text from a document (key information extraction)
* Answering specific questions about documents (document question answering)

Heaps of papers sitting unprocessed can now turn into rich harvests. Through Fetch, even your crumpled receipts are worth something!

- Talk about FormNet and use that to represent docuements as graphs.
<!-- End Move Block -->



- End with how you've learning about topology / geometry and larger understanding of the world


### Notes

- Features may be close together in euclidean space (cosine similarity etc)
- May also have topological, or structural similarities that can also be leveraged
- Graphs can let us learn from both the feature and their structure/connectivity/neighborhood



<br>



## References
